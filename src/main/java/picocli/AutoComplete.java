/*
   Copyright 2017 Remko Popma

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
package picocli;

import java.io.File;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import static java.lang.String.*;

/**
 * Generates a bash auto-complete script.
 */
public class AutoComplete {
    private AutoComplete() {
    }

    static interface Function<T, V> {
        V apply(T t);
    }

    /**
     * Drops all characters that are not valid for bash function and identifier names.
     */
    static class Bashify implements Function<CharSequence, String> {
        public String apply(CharSequence value) {
            return bashify(value);
        }
    }
    private static String bashify(CharSequence value) {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < value.length(); i++) {
            char c = value.charAt(i);
            if (Character.isLetterOrDigit(c) || c == '_') {
                builder.append(c);
            } else if (Character.isSpaceChar(c)) {
                builder.append('_');
            }
        }
        return builder.toString();
    }
    static class EnumNameFunction implements Function<Enum<?>, String> {
        @Override public String apply(final Enum<?> anEnum) {
            return anEnum.name();
        }
    }

    static class NullFunction implements Function<CharSequence, String> {
        @Override public String apply(CharSequence value) { return value.toString(); }
    }

    static interface Predicate<T> {
        boolean test(T t);
    }
    static class BooleanFieldFilter implements Predicate<Field> {
        @Override public boolean test(Field f) {
            return f.getType() == Boolean.TYPE || f.getType() == Boolean.class;
        }
    }
    static class EnumFieldFilter implements Predicate<Field> {
        @Override public boolean test(Field f) {
            return f.getType().isEnum();
        }
    }
    static <T> Predicate<T> negate(final Predicate<T> original) {
        return new Predicate<T>() {
            @Override public boolean test(T t) {
                return !original.test(t);
            }
        };
    }
    private static <T> List<T> filter(List<T> list, Predicate<T> filter) {
        List<T> result = new ArrayList<T>();
        for (T t : list) { if (filter.test(t)) { result.add(t); } }
        return result;
    }

    private static final String HEADER = "" +
            "#!bash\n" +
            "#\n" +
            "# %1$s Bash Completion\n" +
            "# =======================\n" +
            "#\n" +
            "# Bash completion support for %1$s,\n" +
            "# generated by [picocli](http://picocli.info/).\n" +
            "#\n" +
            "# Installation\n" +
            "# ------------\n" +
            "#\n" +
            "# 1. Place this file in a `bash-completion.d` folder:\n" +
            "#\n" +
            "#   * /etc/bash-completion.d\n" +
            "#   * /usr/local/etc/bash-completion.d\n" +
            "#   * ~/bash-completion.d\n" +
            "#\n" +
            "# 2. Open a new bash console, and type `%1$s [TAB][TAB]`\n" +
            "#\n" +
            "# Documentation\n" +
            "# -------------\n" +
            "# The script is called by bash whenever [TAB] or [TAB][TAB] is pressed after\n" +
            "# '%1$s (..)'. By reading entered command line parameters, it determines possible\n" +
            "# bash completions and writes them to the COMPREPLY variable. Bash then\n" +
            "# completes the user input if only one entry is listed in the variable or\n" +
            "# shows the options if more than one is listed in COMPREPLY.\n" +
            "#\n" +
            "# References\n" +
            "# ----------\n" +
            "# [1] http://stackoverflow.com/a/12495480/1440785\n" +
            "# [2] http://tiswww.case.edu/php/chet/bash/FAQ\n" +
            "# [3] https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html\n" +
            "# [4] https://stackoverflow.com/questions/17042057/bash-check-element-in-array-for-elements-in-another-array/17042655#17042655\n" +
            "#\n" +
            "\n" +
            "# Enable programmable completion facilities (see [3])\n" +
            "shopt -s progcomp\n" +
            "\n" +
            "# ArrContains takes two arguments, both of which are the name of arrays.\n" +
            "# It creates a temporary hash from lArr1 and then checks if all elements of lArr2\n" +
            "# are in the hashtable.\n" +
            "#\n" +
            "# Returns zero (no error) if all elements of the 2nd array are in the 1st array,\n" +
            "# otherwise returns 1 (error).\n" +
            "#\n" +
            "# Modified from [4]\n" +
            "function ArrContains() {\n" +
            "  local lArr1 lArr2\n" +
            "  declare -A tmp\n" +
            "  eval lArr1=(\"\\\"\\${$1[@]}\\\"\")\n" +
            "  eval lArr2=(\"\\\"\\${$2[@]}\\\"\")\n" +
            "  for i in \"${lArr1[@]}\";{ [ -n \"$i\" ] && ((++tmp['$i']));}\n" +
            "  for i in \"${lArr2[@]}\";{ [ -z \"${tmp[$i]}\" ] && return 1;}\n" +
            "  return 0\n" +
            "}\n" +
            "\n";

    private static final String FOOTER = "" +
            "\n" +
            "complete -F _complete_%1$s %1$s\n";

    public static String bash(String scriptName, CommandLine commandLine) {
        if (scriptName == null)  { throw new NullPointerException("scriptName"); }
        if (commandLine == null) { throw new NullPointerException("commandLine"); }
        String result = "";
        result += format(HEADER, scriptName);

        Map<String, CommandLine> function2command = new LinkedHashMap<String, CommandLine>();
        result += generateEntryPointFunction(scriptName, commandLine, function2command);

        for (Map.Entry<String, CommandLine> functionSpec : function2command.entrySet()) {
            result += generateFunctionForCommand(functionSpec.getKey(), functionSpec.getValue());
        }
        result += format(FOOTER, scriptName);
        return result;
    }

    private static String generateEntryPointFunction(String scriptName,
                                                     CommandLine commandLine,
                                                     Map<String, CommandLine> function2command) {
        String HEADER = "" +
                "# Bash completion entry point function.\n" +
                "# _complete_%1$s finds which commands and subcommands have been specified\n" +
                "# on the command line and delegates to the appropriate function\n" +
                "# to generate possible options and subcommands for the last specified subcommand.\n" +
                "function _complete_%1$s() {\n" +
                "  CMDS0=(%1$s)\n" +
//                "  CMDS1=(%1$s gettingstarted)\n" +
//                "  CMDS2=(%1$s tool)\n" +
//                "  CMDS3=(%1$s tool sub1)\n" +
//                "  CMDS4=(%1$s tool sub2)\n" +
//                "\n" +
//                "  ArrContains COMP_WORDS CMDS4 && { _picocli_basic_tool_sub2; return $?; }\n" +
//                "  ArrContains COMP_WORDS CMDS3 && { _picocli_basic_tool_sub1; return $?; }\n" +
//                "  ArrContains COMP_WORDS CMDS2 && { _picocli_basic_tool; return $?; }\n" +
//                "  ArrContains COMP_WORDS CMDS1 && { _picocli_basic_gettingstarted; return $?; }\n" +
//                "  ArrContains COMP_WORDS CMDS0 && { _picocli_%1$s; return $?; }\n" +
//                "  echo \"not found\"\n" +
//                "  _picocli_%1$s; return $?;\n" +
//                "}\n" +
//                "\n" +
//                "complete -F _complete_%1$s %1$s\n" +
//                "\n";
                "";
        String FOOTER = "" +
                "  ArrContains COMP_WORDS CMDS0 && { _picocli_%1$s; return $?; }\n" +
                "  echo \"not found\"\n" +
                "  _picocli_%1$s; return $?;\n" +
                "}\n";

        StringBuilder buff = new StringBuilder(1024);
        buff.append(format(HEADER, scriptName));

        List<String> predecessors = new ArrayList<String>();
        predecessors.add(scriptName);
        List<String> functionCallsToArrContains = new ArrayList<String>();

        function2command.put(scriptName, commandLine);
        generateFunctionCallsToArrContains(predecessors, commandLine, buff, functionCallsToArrContains, function2command);

        buff.append("\n");
        Collections.reverse(functionCallsToArrContains);
        for (String func : functionCallsToArrContains) {
            buff.append(func);
        }
        buff.append(format(FOOTER, scriptName));
        return buff.toString();
    }

    private static void generateFunctionCallsToArrContains(List<String> predecessors,
                                                           CommandLine commandLine,
                                                           StringBuilder buff,
                                                           List<String> functionCalls,
                                                           Map<String, CommandLine> function2command) {

        // breadth-first: generate command lists and function calls for predecessors + each subcommand
        for (Map.Entry<String, CommandLine> entry : commandLine.getSubcommands().entrySet()) {
            int count = functionCalls.size() + 1;
            String functionName = "_picocli_" + concat("_", predecessors, entry.getKey(), new Bashify());
            functionCalls.add(format("  ArrContains COMP_WORDS CMDS%2$d && { %1$s; return $?; }\n", functionName, count));
            buff.append(      format("  CMDS%2$d=(%1$s)\n", concat(" ", predecessors, entry.getKey(), new Bashify()), count));

            // remember the function name and associated subcommand so we can easily generate a function later
            function2command.put(functionName, entry.getValue());
        }

        // then recursively do the same for all nested subcommands
        for (Map.Entry<String, CommandLine> entry : commandLine.getSubcommands().entrySet()) {
            predecessors.add(entry.getKey());
            generateFunctionCallsToArrContains(predecessors, entry.getValue(), buff, functionCalls, function2command);
            predecessors.remove(predecessors.size() - 1);
        }
    }
    private static String concat(String infix, String... values) {
        return concat(infix, Arrays.asList(values));
    }
    private static String concat(String infix, List<String> values) {
        return concat(infix, values, null, new NullFunction());
    }
    private static <V, T extends V> String concat(String infix, List<T> values, T lastValue, Function<V, String> normalize) {
        StringBuilder sb = new StringBuilder();
        for (T val : values) {
            if (sb.length() > 0) { sb.append(infix); }
            sb.append(normalize.apply(val));
        }
        if (lastValue == null) { return sb.toString(); }
        if (sb.length() > 0) { sb.append(infix); }
        return sb.append(normalize.apply(lastValue)).toString();
    }

    private static String generateFunctionForCommand(String functionName, CommandLine commandLine) {
        String HEADER = "" +
                "\n" +
                "function %s() {\n" +
                "  # Get completion data\n" +
                "  CURR_WORD=${COMP_WORDS[COMP_CWORD]}\n" +
                "  PREV_WORD=${COMP_WORDS[COMP_CWORD-1]}\n" +
                "\n" +
                "  COMMANDS=\"%s\"\n" +  // COMMANDS="gettingstarted tool"
                "  FLAG_OPTS=\"%s\"\n" + // FLAG_OPTS="--verbose -V -x --extract -t --list"
                "  ARG_OPTS=\"%s\"\n";   // ARG_OPTS="--host --option --file -f -u --timeUnit"

        String FOOTER = "" +
                "\n" +
                "  COMPREPLY=( $(compgen -W \"${FLAG_OPTS} ${ARG_OPTS} ${COMMANDS}\" -- ${CURR_WORD}) )\n" +
                "}\n";

        // Get the fields annotated with @Option and @Parameters for the specified CommandLine.
        List<Field> optionFields = new ArrayList<Field>();
        List<Field> positionalFields = new ArrayList<Field>();
        extractOptionsAndParameters(commandLine, optionFields, positionalFields);

        // Build a list of "flag" options that take no parameters and "arg" options that do take parameters, and subcommands.
        String flagOptionNames = optionNames(filter(optionFields, new BooleanFieldFilter()));
        List<Field> argOptionFields = filter(optionFields, negate(new BooleanFieldFilter()));
        String argOptionNames = optionNames(argOptionFields);
        String commands = concat(" ", new ArrayList<String>(commandLine.getSubcommands().keySet())).trim();

        // Generate the header: the function declaration, CURR_WORD, PREV_WORD and COMMANDS, FLAG_OPTS and ARG_OPTS.
        StringBuilder buff = new StringBuilder(1024);
        buff.append(format(HEADER, functionName, commands, flagOptionNames, argOptionNames));

        // Generate completion lists for options with a known set of valid values.
        // Starting with java enums.
        List<Field> enumOptions = filter(optionFields, new EnumFieldFilter());
        for (Field f : enumOptions) {
            buff.append(format("  %s_OPTION_ARGS=\"%s\" # %s values\n",
                    bashify(f.getName()),
                    concat(" ", Arrays.asList((Enum[]) f.getType().getEnumConstants()), null, new EnumNameFunction()).trim(),
                    f.getType().getSimpleName()));
        }
        // TODO generate completion lists for other option types:
        // Charset, Currency, Locale, TimeZone, ByteOrder,
        // javax.crypto.Cipher, javax.crypto.KeyGenerator, javax.crypto.Mac, javax.crypto.SecretKeyFactory
        // java.security.AlgorithmParameterGenerator, java.security.AlgorithmParameters, java.security.KeyFactory, java.security.KeyPairGenerator, java.security.KeyStore, java.security.MessageDigest, java.security.Signature
        // sql.Types?

        // Now generate the "case" switches for the options whose arguments we can generate completions for
        buff.append(generateOptionsSwitch(argOptionFields, enumOptions));

        // Generate the footer: a default COMPREPLY to fall back to, and the function closing brace.
        buff.append(format(FOOTER));
        return buff.toString();
    }

    private static String generateOptionsSwitch(List<Field> argOptionFields, List<Field> enumOptions) {
        StringBuilder buff = new StringBuilder(1024);
        buff.append("\n");
        buff.append("  case ${CURR_WORD} in\n"); // outer case
        String outerCases = generateOptionsCases(argOptionFields, enumOptions, "", "\"\"");
        if (outerCases.length() == 0) {
            return "";
        }
        buff.append(outerCases);
        buff.append("    *)\n");
        buff.append("      case ${PREV_WORD} in\n"); // inner case
        buff.append(generateOptionsCases(argOptionFields, enumOptions, "    ", "$CURR_WORD"));
        buff.append("      esac\n"); // end inner case
        buff.append("  esac\n"); // end outer case
        return buff.toString();
    }

    private static String generateOptionsCases(List<Field> argOptionFields, List<Field> enumOptions, String indent, String currWord) {
        StringBuilder buff = new StringBuilder(1024);
        for (Field f : argOptionFields) {
            CommandLine.Option option = f.getAnnotation(CommandLine.Option.class);
            if (enumOptions.contains(f)) {
                buff.append(format("%s    %s)\n", indent, concat("|", option.names()))); // "    -u|--timeUnit)\n"
                buff.append(format("%s      COMPREPLY=( $( compgen -W \"${%s_OPTION_ARGS}\" -- %s ) )\n", indent, f.getName(), currWord));
                buff.append(format("%s      return $?\n", indent));
                buff.append(format("%s      ;;\n", indent));
            } else if (f.getType().equals(File.class) || "java.nio.file.Path".equals(f.getType().getName())) {
                buff.append(format("%s    %s)\n", indent, concat("|", option.names()))); // "    -f|--file)\n"
                buff.append(format("%s      compopt -o filenames\n", indent));
                buff.append(format("%s      COMPREPLY=( $( compgen -f -- %s ) ) # files\n", indent, currWord));
                buff.append(format("%s      return $?\n", indent));
                buff.append(format("%s      ;;\n", indent));
            } else if (f.getType().equals(InetAddress.class)) {
                buff.append(format("%s    %s)\n", indent, concat("|", option.names()))); // "    -h|--host)\n"
                buff.append(format("%s      compopt -o filenames\n", indent));
                buff.append(format("%s      COMPREPLY=( $( compgen -A hostname -- %s ) )\n", indent, currWord));
                buff.append(format("%s      return $?\n", indent));
                buff.append(format("%s      ;;\n", indent));
            }
        }
        return buff.toString();
    }

    private static String optionNames(List<Field> optionFields) {
        List<String> result = new ArrayList<String>();
        for (Field f : optionFields) {
            CommandLine.Option option = f.getAnnotation(CommandLine.Option.class);
            result.addAll(Arrays.asList(option.names()));
        }
        return concat(" ", result, "", new NullFunction()).trim();
    }

    private static void extractOptionsAndParameters(CommandLine commandLine,
                                                    List<Field> optionFields,
                                                    List<Field> positionalParameterFields) {

        Map<String, Field> optionName2Field = new LinkedHashMap<String, Field>();
        Class<?> cls = commandLine.getCommand().getClass();
        while (cls != null) {
            CommandLine.init(cls, new ArrayList<Field>(), optionName2Field, new HashMap<Character, Field>(), positionalParameterFields);
            cls = cls.getSuperclass();
        }
        for (Field f : optionName2Field.values()) {
            if (!optionFields.contains(f)) { optionFields.add(f); }
        }
    }
}
