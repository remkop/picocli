= picocli - a mighty tiny Command Line Interface
Remko Popma <rpopma@apache.org>
v0.3.0, 2017-03-25
:toc: left
:numbered:
:toclevels: 2
:toc-title: Features

A Java command line parsing framework in a single file, so you can include it _in source form_
and your users can run your application without an external dependency.
Produces beautiful and easily tailored usage help messages.

How it works: annotate your class and picocli initializes it from the command line arguments,
converting the input to strongly typed values in the fields of your class.

== Example

[source,java]
----
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;
import java.io.File;

public class Example {
    @Parameters(description = "Specifies the input file(s).")
    private File[] inputFiles;

    @Option(names = { "-v", "--verbose" }, description = "Be verbose.")
    private boolean verbose = false;

    @Option(names = { "-h", "--help" }, help = true,
            description = "Displays this help message and quits.")
    private boolean helpRequested = false;
    ...
}
----

Then invoke `CommandLine.parse` with the command line parameters and an object you want to initialize.

[source,java]
----
Example app = CommandLine.parse(new Example(), "-v", "inputFile1", "inputFile2");
assert !app.helpRequested;
assert  app.verbose;
assert  app.inputFiles != null && app.inputFiles.length == 2;
----

== Options and Parameters
Options have a name, positional parameters (sometimes called operands) come after the named options.
There are no hard and fast rules for when to use options or parameters,
but a common theme seems to be that options are optional and parameters are used for mandatory values.
Picocli lets you make options required if you want to, see <<Required Options>>.

TIP: The https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html#Command_002dLine-Interfaces[GNU recommendations] for command line interfaces and http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02[POSIX Utility Guidelines] may be useful.

=== Options
An option can have multiple names. Options usually have a prefix to distinguish them from parameters. There are many different prefixes and different option naming https://en.wikipedia.org/wiki/Command-line_interface#Command-line_option[styles]. Picocli lets you use any style you want.

TIP: You may be interested in this http://catb.org/~esr/writings/taoup/html/ch10s05.html#id2948149[list of common option names]. Following these conventions may make your application more intuitive to use.

The below uses the popular utility `tar` as an example to show how one could use picocli to code options with one or more names, options that take an option parameter, positional parameters, and "help" options.
[source,java]
----
class Tar {
    @Option(names = { "-c", "--create" }, description = "create a new archive")
    boolean create;

    @Option(names = "-x", description = "extract files from an archive")
    boolean extract;

    @Option(names = { "-f", "--file" }, valueLabel = "ARCHIVE",
            description = "use archive file or device ARCHIVE")
    File archive;

    @Option(names = { "-v", "--verbose" }, description = "verbosely list files processed")
    boolean verbose;

    @Option(names = { "-h", "-?", "--help" }, help = true,
            description = "give this help list")
    boolean helpRequested;

    @Option(names = { "-V", "--version" }, help = true,
            description = "print program version")
    boolean versionRequested;

    @Parameters(valueLabel = "FILE", description = "one ore more files to archive")
    File[] files;
}
----

=== Positional Parameters
Positional parameters (also called operands) are the command line arguments following the options.
Positional parameters can be captured together as an array or a List, or you can capture individual parameters in separate fields. The advantage of capturing individual parameters in separate fields is that you can enforce strong typing. For example:

[source,java]
----
class PositionalParameters {
    @Parameters(hidden = true) // don't show this parameter in usage help message
    List<String> allParameters;

    @Parameters(index = 0, valueLabel = "<host>",
                description = "Host name or IP address to connect to")
    InetAddress host;

    @Parameters(index = 1, valueLabel = "<port>",
                description = "Port number to connect to")
    int port;
}
----

If all parameters are the same type, you can capture them together in a single array or `Collection` field.  For example:

[source,java]
----
class Convert {
    @Parameters(type = File.class, valueLabel = "FILES",
                description = "The files to convert.")
    List<File> files;
}
----

IMPORTANT: With array fields picocli uses reflection to discover the array element type, but with collections, Java type erasure means picocli cannot find out the generic type of the collection. The above example uses the `type` attribute to explicitly tell picocli what type to convert the command line arguments to.

=== Double dash (`--`)
When one of the command line arguments is two dashes without any characters attached (`--`), picocli interprets all following arguments as positional parameters, even arguments that match an option name.

[source,java]
----
class DoubleDash {
    @Parameters
    List<String> params;

    @Option(names = "--files")
    List<String> files;

    @Option(names = { "-v", "--verbose" })
    boolean verbose;
}

String[] args = {"-v", "--", "--files", "inputFile1", "inputFile2"};
DoubleDash doubleDash = CommandLine.parse(new DoubleDash(), args);

assert doubleDash.verbose;
assert doubleDash.files == null;
assert doubleDash.params != null && doubleDash.params.length == 3;
assert doubleDash.params.equals(Arrays.asList("--files", "inputFile1", "inputFile2"));
----

== Type Conversion
When command line options and parameters are mapped to the annotated fields,
the text value is converted to the type of the annotated field.

=== Built-in Type Converters
Out of the box, picocli can convert command line argument strings to any Java primitive type or their wrapper,
File, BigDecimal, BigInteger, InetAddress, URL, URI, Charset, UUID, regex Pattern, String, StringBuilder, CharSequence,
`java.sql.Time` (for values in any of the `"HH:mm"`, `"HH:mm:ss"`, `"HH:mm:ss.SSS"`, or `"HH:mm:ss,SSS"` formats), and
`java.util.Date` (for values in `"yyyy-MM-dd"` format).

=== Custom Type Converters
Register a custom converter to handle data types other than the above built-in ones.

Custom converters need to implement the `picocli.CommandLine.ITypeConverter` interface:

[source,java]
----
public interface ITypeConverter<K> {
    /**
     * Converts the specified command line option value to some domain object.
     * @param value the command line option String value
     * @return the resulting domain object
     * @throws Exception an exception detailing what went wrong during the conversion
     */
    K convert(String value) throws Exception;
}
----

Custom type converters can be registered with the `CommandLine.registerConverter(Class<K> cls, ITypeConverter<K> converter)`
method.


NOTE: Picocli works with Java 5 and higher, so it does not have default converters for Java 8 types like `Path` or
`Duration`. Lambdas make it easy to register custom converters for these types:

[source,java]
----
 commandLine.registerConverter(java.nio.file.Path.class, s -> java.nio.file.Paths.get(s));
 commandLine.registerConverter(java.time.Duration.class, s -> java.time.Duration.parse(s));
----

NOTE: Numeric values are interpreted as decimal numbers by default. If you want picocli to be more flexible, you can
use the https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#decode-java.lang.String-[decode] method
to convert strings to numbers. The `decode` method looks at the prefix to determine the radix, so numbers
starting with `0x`, `0X` or `#` are interpreted as hexadecimal numbers, numbers starting with `0` are interpreted
as octal numbers, and otherwise the number is interpreted as a decimal number.

[source,java]
----
 commandLine.registerConverter(Byte.class,    s -> Byte::decode);
 commandLine.registerConverter(Short.class,   s -> Short::decode);
 commandLine.registerConverter(Integer.class, s -> Integer::decode);
 commandLine.registerConverter(Long.class,    s -> Long::decode);
----


== Putting it all Together
Imagine an application that takes some input files and compresses them to an output file.
----
Compress -o outputFile file1 file2 file3
----
The program takes one option (`-o`, the output file) and one or more input files.
One way to accomplish this with picoCLI looks like this:

[source, java]
----
import picocli.CommandLine.*;
import java.io.File;

@Command(name = "Compress", header = "Compresses the specified input files to an output file")
public class Compress {
    @Parameters(arity = "1..*", description = "one or more files to compress")
    File[] inputFiles;

    @Option(names = {"-o", "--outfile"}, description = "optional output file name. If omitted directory name is used.")
    File outputFile;

    @Option(names = {"-h", "--help"}, help = true, description = "display this help message")
    boolean helpRequested;

    public static void main(String... args) {
        try {
            Compress compress = CommandLine.parse(new Compress(), args);
            if (compress.helpRequested) {
                CommandLine.usage(new Compress(), System.err);
                return;
            }
            doCompress();
        } catch (ParseException ex) {
            System.err.println(ex.getMessage());
            CommandLine.usage(new Compress(), System.err);
        }
    }

    private void doCompress() { ... } // business logic of the application
}
----

== Command Line Flags and Switches
Boolean options don't need a parameter. If the option name is specified on the command line, the corresponding field is set to `true`:

[source, java]
----
class MyProgram {
    @Option(names = { "-v", "--verbose" }, description = "Verbose mode")
    boolean verbose;
}
----

The boolean field `verbose` will have value `true` when the program is invoked with the "-v" option:
----
CommandLine.parse(new MyProgram(), { "-v", "arg1", "arg2" });
----

=== Explicit Boolean Parameters
It is possible to explicitly specify "true" or "false" as a parameter for a boolean option by defining an explicit <<Arity: Minimum and Maximum Number of Parameters,`arity`>> attribute. A boolean option with `arity = "0..1"` accepts zero to one parameters, `arity = "1"` means the option _must_ have one parameter. For example:

[source, java]
----
class MyProgram {
    @Option(names = "-x", arity = "1", description = "boolean option with 1 mandatory parameter")
    boolean x;

    @Option(names = "-y", arity = "0..1", description = "boolean option with minimum 0 and maximum 1 parameter")
    boolean y;
}
----

The following ways to invoke the program will be accepted (values are not case sensitive):
----
<main> -x true
<main> -x FALSE
<main> -x TRUE -y
<main> -x True -y False
----

But trying to specify the `-x` option without a parameter, or with a value other than "true" or "false" (case insensitive) will result in a `ParameterException`.

== Arity: Minimum and Maximum Number of Parameters
Option fields of type array or `List` (or any class extending `Collection`) will be able to hold multiple values. The `arity` attribute can be used to specify the exact number of required parameters, or a range with a minimum and a maximum number of parameters. The maximum can be a fixed number, or can be `"*"` to denote "any number" of parameters. For example:
[source, java]
----
class MyProgram {
    @Parameters(arity = "3", descriptions = "exactly three Files")
    File[] files;

    @Option(names = "-f", arity = "2..4", description = "two to four floating point numbers")
    double[] doubles;

    @Option(names = "-s", arity = "1..*", description = "at least one string")
    String[] strings;
}
----
A `MissingParameterException` is thrown when fewer than the miminum number of required parameters is specified as command line arguments. Options with an exact number or an exact range will consume up to the maximum number of parameters.

=== Auto-detect New Options
Once the minimum number of parameters is consumed, picoCLI will check for each subsequent command line argument whether it is another parameter, or a new option. For example:

----
<main> -s A B C -f 1.0 2.0 3.0
----
The above command line arguments will be parsed as three parameters for the `-s` option, followed by three parameters for the `-f` option.

=== Ambiguous Input
Positional parameters do not have an option name, and the below example command line arguments will be parsed as six parameters for the `-s` option, not as three strings and three files:
----
<main> -s A B C file1 file2 file3
----

Users can disambiguate the input by specifying a double dash (`--`) after the option parameters.
The argument `--` is interpreted as a delimiter indicating the end of options. Any following arguments are treated as positional parameters. For example, the following command line arguments will be parsed as three strings and three files:
----
<main> -s A B C -- file1 file2 file3
----

== Default Arity: Number of Parameters Depends on Option Type
Most of the time options don't need to define their arity explicitly. When the arity is not specified, the implicit arity of the option depends on the field's type:

* Boolean fields: `"0"`. By default no parameters are required or expected.
* Single-valued types (primitive fields, Number fields, String, File etc): `"1"`. By default option fields with these types expect a single value.
* Multi-valued types (arrays or classes extending `Collection`): `"0..*"`. By default option fields with this type have no mandatory parameters but accept any number of parameters.

== Required Options
Options can be marked `required` to make it mandatory for the user to specify them on the command line. When a required option is not specified, a `MissingParameterException` is thrown from the `parse` method. For example:
[source, java]
----
class MyProgram {
    @Parameters(arity = "3", descriptions = "exactly three Files")
    File[] files;

    @Option(names = "-x", description = "optional switch")
    boolean x;

    @Option(names = "-y", required = true, description = "mandatory switch")
    boolean y;

    @Option(names = "-n", required = true, description = "mandatory number")
    int number;
}
----
The following command line arguments would result in an exception complaining that `y` and `number` are missing:
----
CommandLine.parse(new MyProgram(), "-x file1 file2 file3")
----
The following command line arguments would be accepted:
----
CommandLine.parse(new MyProgram(), "-x -y -n 123 file1 file2 file3")
----


// TODO document that if arity>1 and args="-opt=val1 val2", arity overrules the "=": both values are assigned


== Options with Parameters
== parameters are strongly typed
== built-in type converters
== registering custom type converters
== option short form

== Clustered Short Options
Single-character options preceded with a '-', like `-v` or `-r`, can be grouped, so `-vxr` is equivalent to `-v -x -r`.

// TODO ambiguous short options: ambiguity with the -f FILE and -fFILE notation.
// TODO ambiguous options: writing --input ARG (as opposed to --input=ARG) is ambiguous,

== Reusing Options and Command Attributes
Picocli will walk the class hierarchy to check for annotations, so you can declare common @Options and @Command attributes on a superclass and override these fields or attributes on a subclass.

The below example shows how common options like `help` and `version` can be declared as fields in a superclass so they are available in all subclasses. Similarly, annotating the superclass with default `@Command` attributes means subclasses won't need to set these attributes.

[source,java]
----
@Command(synopsisHeading      = "%nUsage:%n%n,       descriptionHeading = "%nDescription:%n%n,
         parameterListHeading = "%nParameters:%n%n", optionListHeading  = "%nOptions:%n%n",
         commandListHeading   = "%nCommands:%n%n",   showDefaultValues  = false)
public abstract class AbstractCommand {

    @Option(names = { "-h", "-?", "--help" }, help = true,
            description = "give this help list")
    protected boolean helpRequested;

    @Option(names = { "-V", "--version" }, help = true,
            description = "print program version")
    protected boolean versionRequested;
}

@Command(name        = "zip",
         header      = "Compresses the specified FILE(s).",
         description = "The default action is to add or replace zipfile entries from list, " +
                       "which can include the special name - to compress standard input.",
         footer      = "Copyright (c) 1990-2008 Info-ZIP - Type 'zip "-L"' for software license.")
public class ZipCommand extends AbstractCommand {
    @Option(names = { "-o", "--output" }, description = "output file to write to")
    private File output;

    @Parameter(valueLabel = "FILE", description = "FILEs to compress")
    private File[] files;
}
----

== Download

NOTE: Here is the source. Copy and paste it into a file called `CommandLine.java`, add it to your project, and enjoy!

[source,java]
----
include::../src/main/java/picocli/CommandLine.java[]
----